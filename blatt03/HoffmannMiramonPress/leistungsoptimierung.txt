Wir bezeichnen die Aufrufe für unsere Vergleichsmessungen wiefolgt:

Jacobi-1:       ./partdiff-seq 1 2 64 1 2 10240
Jacobi-2:       ./partdiff-seq 1 2 64 2 2 5120



KEINE OPTIMIERUNG (-O0):

Jacobi-1:       110.718604 s
Jacobi-2:       133.954952 s



###############################################################################
--------------------------- 1 Compiler-Optimierungen --------------------------
###############################################################################

OPTIMIERUNG (-O1):

Jacobi-1:       51.276483 s
Jacobi-2:       88.200447 s


OPTIMIERUNG (-O2):

Jacobi-1:       50.189537 s
Jacobi-2:       80.093677 s


OPTIMIERUNG (-O3):

Jacobi-1:       48.059804 s
Jacobi-2:       79.457755 s

-O3 optimiert am meisten, weshalb die Laufzeit mit -O3 auch am besten ist.


(weitere ungetestete und ungeeignete Optimierungen:)
-Os: optimiert die Größe 
-Ofast: wie O3, aber ungenauere Berechnungen  
-Og: wie O1, aber besseres Debugging  
-Oz: optimiert hauptsächlich die Größe und nicht Zeit



###############################################################################
----------------------------------- 2 GPROF -----------------------------------
###############################################################################

Da das Kompilieren mit -O3 die Struktur des Codes stark verändern kann, 
und gprof nicht mehr nachverfolgen kann, wo wieviel Zeit aufgewendet wird,
führen wir gprof mit der originalen Optimierung -O0 aus.


srun gprof ./partdiff-seq
Flat profile:

Each sample counts as 0.01 seconds.
  %   cumulative   self              self     total
 time   seconds   seconds    calls   s/call   s/call  name
 91.03     86.88    86.88        1    86.88    94.29  calculate
  7.76     94.29     7.40 2758256640     0.00     0.00  getResiduum
  1.15     95.39     1.10        1     1.10     1.10  initMatrices
  0.00     95.39     0.00        4     0.00     0.00  allocateMemory
  0.00     95.39     0.00        1     0.00     0.00  AskParams
  0.00     95.39     0.00        1     0.00     0.00  DisplayMatrix
  0.00     95.39     0.00        1     0.00     0.00  allocateMatrices
  0.00     95.39     0.00        1     0.00     0.00  displayStatistics
  0.00     95.39     0.00        1     0.00     0.00  freeMatrices
  0.00     95.39     0.00        1     0.00     0.00  initVariables


Mit gprof sieht man, dass sich das Programm 91% der Zeit in calculate befindet,
wobei ein Aufruf von calculate 86.88 Sekunden dauert. Demnach wissen wir, dass 
wir hauptsächlich die Funktion calculate ändern bzw. optimieren müssen.

Nach calculate benötigt die Funktion getResiduum mit 7,8% am meisten Zeit. 
Dies liegt aber daran, dass sie sehr häufig aufgerufen wird (2758256640 mal),
denn pro Aufruf braucht getResidum ~0.00 Sekunden. 

Außerdem sehen wir, dass ein Aufruf von initMatrices 1.1 Sekunden dauert.
Hier könnte man ggf. auch etwas optimieren.



###############################################################################
----------------------------------- 3 PERF ------------------------------------
###############################################################################

Wir nutzen hier für perf ebenfalls die Kompilierung mit -O0.

 Performance counter stats for './partdiff-seq 1 2 64 1 2 10240':

        136,294.90 msec task-clock                #    0.999 CPUs utilized
            11,512      context-switches          #    0.084 K/sec
                 1      cpu-migrations            #    0.000 K/sec
             1,134      page-faults               #    0.008 K/sec
   362,822,331,164      cycles                    #    2.662 GHz                      (83.35%)
   158,235,636,390      stalled-cycles-frontend   #   43.61% frontend cycles idle     (83.33%)
    20,277,967,751      stalled-cycles-backend    #    5.59% backend cycles idle      (66.67%)
   629,611,362,351      instructions              #    1.74  insn per cycle
                                                  #    0.25  stalled cycles per insn  (83.35%)
    52,464,330,840      branches                  #  384.932 M/sec                    (83.33%)
         9,336,441      branch-misses             #    0.02% of all branches          (83.33%)

     136.399610819 seconds time elapsed

     136.320085000 seconds user
       0.000000000 seconds sys


#TODO:  Erläutern Sie die Bedeutung der einzelnen Statistiken und mögliche 
        Einflüsse auf die Leistung Ihres Programmes. 



###############################################################################
------------------------- 4 Berechnungs-optimierungen -------------------------
###############################################################################

Wir nutzen ab jetzt die Optimierungsflag -O3. Die Zeilenangaben beziehen sich
auf die unformatierte Original-Datei.


Zeile 219-223:
Als erstes haben wir in calculate die Iteration über Spalten und Zeilen 
vertauscht, da ursprünglich erst über alle Zeilen und dann alle Spalten
iteriert wurde. So muss immer ein Speicherbereich zur nächsten Zeile über-
sprungen werden, was deutlich länger dauert, als einfach die Zeilen 
hintereinander (also immer das nächste Element im Speicherbereich) aufzurufen.

Jacobi-1:       18.726063 s
Jacobi-2:       77.242255 s



Zeile 232: 
Wir verschieben die Zeile 232 direkt unter Zeile 228, da in Zeile 228 die 
Variable korrektur initialisiert wird und sie nach Zeile 232 nicht mehr 
benötigt wird. Nun muss korrektur nicht mehr gespeichert werden, während
andere Berechnungen ausgeführt werden.
228             korrektur = residuum;
                ...
232				Matrix[m1][i][j] = Matrix[m2][i][j] + korrektur;

Jacobi-1:       17.285843 s
Jacobi-2:       75.378576 s



Weitere Ideen zur Laufzeit-Optimierung, welche aber keinen Unterschied gemacht 
haben oder wir uns nicht sicher waren, ob wir dies ändern sollen/dürfen:
    -   löschen von m1 und m2 exchange in calculate und results->m = m1;
    -   Matrizen mit calloc statt malloc allokieren, um 0-Initialisierung
        in initMatrices nicht zu benötigen
    -   switch statt if/else cases beim termination check in calculate 
        (TERM_PREC, TERM_ITER) und getResiduum (FUNC_F0, default)
    -   fabs() statt residuum = (residuum < 0) ? -residuum : residuum;


    -   löschen von Zeile 229 und 230: 
229             residuum = (residuum < 0) ? -residuum : residuum;
230				results->stat_precision = (residuum < results->stat_precision) ? results->stat_precision : residuum;

        Das Entfernen von Zeile 229 und 230 macht das Programm deutlich schneller
        und man erhält die gleichen Ergebnisse.

        Jacobi-1:       5.616056 s
        Jacobi-2:       39.756336 s